        - function getInitialPrimitive(configData)
        0     rho_inf = configData["core"]["rho_inf"]::Float64
        0     mach = configData["core"]["mach"]::Float64
        0     machcos::Float64 = mach * cos(calculateTheta(configData))
        0     machsin::Float64 = mach * sin(calculateTheta(configData))
        0     pr_inf = configData["core"]["pr_inf"]::Float64
        0     primal = [rho_inf, machcos, machsin, pr_inf]
        0     return primal
        - end
        - 
        - function getInitialPrimitive2(configData)
        -     dataman = open("prim_soln_clean")
        -     data = read(dataman, String)
        -     data1 = split(data, "\n")
        -     finaldata = Array{Array{Float64,1},1}(undef, 0)
        -     for (idx,itm) in enumerate(data1)
        -         # try
        -         da = split(itm)
        -         da1 = parse.(Float64, da)
        -         push!(finaldata, da1)
        -     end
        -     close(dataman)
        -     return finaldata
        - end
        - 
        - function calculateNormals(left, right, mx, my)
        -     lx = left[1]
        -     ly = left[2]
        - 
        -     rx = right[1]
        -     ry = right[2]
        - 
        -     nx1 = my - ly
        -     nx2 = ry - my
        - 
        -     ny1 = mx - lx
        -     ny2 = rx - mx
        - 
        -     nx = 0.5*(nx1 + nx2)
        -     ny = 0.5*(ny1 + ny2)
        - 
        -     det = hypot(nx, ny)
        - 
        -     nx = -nx/det
        -     ny = ny/det
        - 
        -     return (nx,ny)
        - end
        - 
        - function calculateConnectivity(globaldata, idx)
        -     ptInterest = globaldata[idx]
        -     currx = ptInterest.x
        -     curry = ptInterest.y
        -     nx = ptInterest.nx
        -     ny = ptInterest.ny
        - 
        -     flag = ptInterest.flag_1
        - 
        -     xpos_conn,xneg_conn,ypos_conn,yneg_conn = Array{Int32,1}(undef, 0),Array{Int32,1}(undef, 0),Array{Int32,1}(undef, 0),Array{Int32,1}(undef, 0)
        - 
        -     tx = ny
        -     ty = -nx
        - 
        -     for itm in ptInterest.conn
        -         itmx = globaldata[itm].x
        -         itmy = globaldata[itm].y
        - 
        -         delx = itmx - currx
        -         dely = itmy - curry
        - 
        -         dels = delx*tx + dely*ty
        -         deln = delx*nx + dely*ny
        -         if dels <= 0.0
        -             push!(xpos_conn, itm)
        -         end
        -         if dels >= 0.0
        -             push!(xneg_conn, itm)
        -         end
        -         if flag == 2
        -             if deln <= 0.0
        -                 push!(ypos_conn, itm)
        -             end
        -             if deln >= 0.0
        -                 push!(yneg_conn, itm)
        -             end
        -         elseif flag == 1
        -             push!(yneg_conn, itm)
        -         elseif flag == 3
        -             push!(ypos_conn, itm)
        -         end
        -     end
        -     return (xpos_conn, xneg_conn, ypos_conn, yneg_conn)
        - end
        - 
        - function fpi_solver(iter, globaldata, configData, wallindices, outerindices, interiorindices, res_old)
        -     # println(IOContext(stdout, :compact => false), globaldata[3].prim)
        -     # print(" 111\n")
       80     if iter == 1
       80         println("Starting FuncDelta")
        -     end
        0     func_delta(globaldata, configData)
        - 
        0     for rk in 1:4
        0         if iter == 1
      320             println("Starting QVar")
        -         end
        0         q_var_derivatives(globaldata, configData)
        -         # println(IOContext(stdout, :compact => false), globaldata[3].prim)
        0         if iter == 1
      656             println("Starting Calflux")
        -         end
        0         cal_flux_residual(globaldata, wallindices, outerindices, interiorindices, configData)
        -         # println(IOContext(stdout, :compact => false), globaldata[3].prim)
        -         # println(IOContext(stdout, :compact => false), globaldata[3].prim)
        -         # residue = 0
        0         if iter == 1
      320             println("Starting StateUpdate")
        -         end
        0         state_update(globaldata, wallindices, outerindices, interiorindices, configData, iter, res_old, rk)
        -     end
      208     println("Iteration Number ", iter)
        -     # println(IOContext(stdout, :compact => false), globaldata[3].prim)
        -     # residue = res_old
        0     return nothing
        - end
        - 
        - function q_var_derivatives(globaldata::Array{Point,1}, configData)
       64     power::Float64 = configData["core"]["power"]
        - 
        0     for (idx, itm) in enumerate(globaldata)
        0         rho = itm.prim[1]
        0         u1 = itm.prim[2]
        0         u2 = itm.prim[3]
        0         pr = itm.prim[4]
        - 
        0         beta::Float64 = 0.5 * (rho / pr)
        0         globaldata[idx].q[1] = log(rho) + log(beta) * 2.5 - (beta * ((u1 * u1) + (u2 * u2)))
        0         two_times_beta = 2.0 * beta
        -         # if idx == 1
        -         #     println(globaldata[idx].q[1])
        -         # end
        0         globaldata[idx].q[2] = (two_times_beta * u1)
        0         globaldata[idx].q[3] = (two_times_beta * u2)
        0         globaldata[idx].q[4] = -two_times_beta
        - 
        -     end
        -     # println(IOContext(stdout, :compact => false), globaldata[3].q)
      448     sum_delx_delq = zeros(Float64, 4)
      448     sum_dely_delq = zeros(Float64, 4)
        0     for (idx, itm) in enumerate(globaldata)
        0         x_i = itm.x
        0         y_i = itm.y
        -         sum_delx_sqr = zero(Float64)
        -         sum_dely_sqr = zero(Float64)
        -         sum_delx_dely = zero(Float64)
        0         sum_delx_delq = fill!(sum_delx_delq, 0.0)
        0         sum_dely_delq = fill!(sum_dely_delq, 0.0)
        0         for i in 1:4
        0             globaldata[idx].max_q[i] = globaldata[idx].q[i]
        0             globaldata[idx].min_q[i] = globaldata[idx].q[i]
        -         end
        0         for conn in itm.conn
        0             x_k = globaldata[conn].x
        0             y_k = globaldata[conn].y
        0             delx = x_k - x_i
        0             dely = y_k - y_i
        0             dist = hypot(delx, dely)
        0             weights = dist ^ power
        0             sum_delx_sqr += ((delx * delx) * weights)
        0             sum_dely_sqr += ((dely * dely) * weights)
        0             sum_delx_dely += ((delx * dely) * weights)
 78646272             sum_delx_delq += @. (weights * delx * (globaldata[conn].q - globaldata[idx].q))
 78646272             sum_dely_delq += @. (weights * dely * (globaldata[conn].q - globaldata[idx].q))
        0             for i in 1:4
        0                 if globaldata[idx].max_q[i] < globaldata[conn].q[i]
        0                     globaldata[idx].max_q[i] = globaldata[conn].q[i]
        -                 end
        0                 if globaldata[idx].min_q[i] > globaldata[conn].q[i]
        0                     globaldata[idx].min_q[i] = globaldata[conn].q[i]
        -                 end
        -             end
        -         end
        0         det = (sum_delx_sqr * sum_dely_sqr) - (sum_delx_dely * sum_delx_dely)
        0         one_by_det = 1.0 / det
  4300800         globaldata[idx].dq[1] = @. one_by_det * (sum_delx_delq * sum_dely_sqr - sum_dely_delq * sum_delx_dely)
  4300800         globaldata[idx].dq[2] = @. one_by_det * (sum_dely_delq * sum_delx_sqr - sum_delx_delq * sum_delx_dely)
        -         # globaldata[idx].dq = [tempsumx, tempsumy]
        -     end
        -     # println(IOContext(stdout, :compact => false), globaldata[3].dq)
        -     # println(IOContext(stdout, :compact => false), globaldata[3].max_q)
        -     # println(IOContext(stdout, :compact => false), globaldata[3].min_q)
        0     return nothing
        - end
        - 
