import argparse
from tqdm import tqdm
import shapely
from shapely.geometry import Polygon, Point
import numpy as np

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file", help="Grid File Location", type=str, default="partGridNew")
    args = parser.parse_args()
    file1 = open(args.file)
    print("Loading file: %s" % args.file)
    data1 = file1.read()
    splitdata = data1.split("\n")
    splitdata = splitdata[:-1]
    globaldata = createGlobalData(splitdata)
    wallpoints = getWallPointArray(globaldata)
    wallpointsData = generateWallPolygons(wallpoints)
    generateOutput(globaldata, wallpoints, wallpointsData)


def createGlobalData(splitdata):
    globaldata = ["start"]
    for itm in tqdm(splitdata):
        itmdata = itm.split(" ")
        globaldata.append([int(itmdata[0]), float(itmdata[1]), float(itmdata[2]), int(itmdata[5]),int(itmdata[6])])
    return globaldata

def getLeftPoint(idx, globaldata):
    None

def getWallPointArray(globaldata):
    wallpointarray = []
    startgeo = 0
    newstuff = []
    for idx,itm in enumerate(globaldata):
        if idx > 0:
            geoflag = int(itm[4])
            if(startgeo == geoflag and getFlag(idx,globaldata) == 1):
                newstuff.append(getPointxy(idx,globaldata))
            if(startgeo != geoflag and getFlag(idx,globaldata) == 1):
                newstuff = []
                wallpointarray.append(newstuff)
                newstuff.append(getPointxy(idx,globaldata))
                startgeo = startgeo + 1
    return wallpointarray

def getWallPointArrayIndex(globaldata):
    wallpointarray = []
    startgeo = 0
    newstuff = []
    for idx,itm in enumerate(globaldata):
        if idx > 0:
            geoflag = int(itm[4])
            if(startgeo == geoflag and getFlag(idx,globaldata) == 1):
                newstuff.append(idx)
            if(startgeo != geoflag and getFlag(idx,globaldata) == 1):
                newstuff = []
                wallpointarray.append(newstuff)
                newstuff.append(idx)
                startgeo = startgeo + 1
    return wallpointarray

def getFlag(idx, globaldata):
    return globaldata[idx][3]

def getPointxy(idx, globaldata):
    return "{},{}".format(globaldata[idx][1], globaldata[idx][2])

def getPoint(idx, globaldata):
    return globaldata[idx][1], globaldata[idx][2]

def generateWallPolygons(wallpoints):
    wallPolygonData = []
    for item in wallpoints:
        polygonpts = []
        for item2 in item:
            polygonpts.append([float(item2.split(",")[0]), float(item2.split(",")[1])])
        polygontocheck = Polygon(polygonpts)
        wallPolygonData.append(polygontocheck)
    return wallPolygonData

def generateOutput(globaldata, wallPointArray, wallShapely):
    numPts = len(globaldata) - 1
    with open("preprocessorfile.poly", "w+") as the_file:
        the_file.write("# Generated by QuadTree Mesh Solver\n\n")
        the_file.write("{} 2 0 1\n".format(numPts))
        geoidx = 0
        segments = 0
        for wallidx, itm in enumerate(wallPointArray):
            the_file.write("# Shape {}\n".format(wallidx + 1))
            for itm2 in itm:
                wallx = float(itm2.split(",")[0])
                wally = float(itm2.split(",")[1])
                geoidx += 1
                segments += 1
                the_file.write("{} {} {} {}\n".format(geoidx, wallx, wally, (wallidx + 1)))
        the_file.write("# Interior Points and Outer Points\n")
        captureOuter = None
        for i in range(geoidx + 1, len(globaldata)):
            ptx, pty = getPoint(i, globaldata)
            flag = getFlag(i, globaldata)
            if flag == 3:
                segments += 1
                if captureOuter == None:
                    captureOuter = i
            the_file.write("{} {} {} {}\n".format(i, ptx, pty, flag + 100))
        the_file.write("# Line Segments\n")
        the_file.write("{} 1\n".format(segments))
        the_file.write("# Wall Line Segments\n")    
        segidx = 0    
        wallPtIndices = getWallPointArrayIndex(globaldata)
        for wallidxI, itm in enumerate(wallPtIndices):
            for idx, wallidx in enumerate(itm):
                if idx == len(itm) - 1:
                    nextPt = itm[0]
                else:
                    nextPt = itm[idx + 1]
                segidx += 1
                the_file.write("{} {} {} {}\n".format(segidx, wallidx, nextPt, (wallidxI + 1)))
        currPt = captureOuter
        the_file.write("# Outer Line Segments\n")
        first_encounter = currPt
        while True:
            if currPt == len(globaldata):
                nextPt = first_encounter
            else:
                nextPt = currPt + 1
            segidx += 1
            the_file.write("{} {} {} {}\n".format(segidx, currPt, nextPt, 103))
            currPt = nextPt
            if int(nextPt) == int(captureOuter):
                break
        the_file.write("{}\n".format(len(wallPointArray)))
        holeidx = 0
        the_file.write("# Holes\n")   
        for itm in wallShapely:
            holeidx += 1
            avgpt = random_points_within(itm, 1)[0]
            avgpt = list(avgpt.coords)[0]
            the_file.write("{} {} {}\n".format(holeidx, avgpt[0], avgpt[1]))


def random_points_within(poly, num_points):
    min_x, min_y, max_x, max_y = poly.bounds

    points = []

    while len(points) < num_points:
        random_point = Point([np.random.uniform(min_x, max_x), np.random.uniform(min_y, max_y)])
        if (random_point.within(poly)):
            points.append(random_point)

    return points


if __name__ == "__main__":
    main()